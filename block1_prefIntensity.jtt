app.numPeriods = app.session.decisionSituations.length * 2;
app.groupSize = 1;

// Disable automatic modification of "src" attributes, instead the full path is pre-specified. Automation does not work with dynamic values yet.
app.modifyPathsToIncludeId = false;

let stage = app.newStage('decide');
stage.playerStart = function(player) {
    let sit = Math.floor((player.period().id-1)/2);
    let situation = app.session.decisionSituations[player.participant.decSitSequence[sit]];
    player.situation = situation;
    player.situationName = situation.name;
    let storeNext = false;
    if (player.participant.useA == null) {
        player.participant.useA = Math.random() < 0.5;
        storeNext = true;
    } 
    player.option = player.participant.useA ? situation.optionA : situation.optionB;
    player.optionText = player.option.text;
    player.participant.useA = !player.participant.useA;
    if (!storeNext) {
        player.participant.useA = null;
    }
    player.switchRow = -1;
    player.previewSwitchRow = -1;
    player.switchToBTokens = -1;
    if (player.period().id === 1) {
        player.participant.latestPayoffs = [];
    }
}
stage.activeScreen = `
    <p>
    Please indicate at which decision you would like to switch from Option A to Option B by putting a check mark in the box of the Switch column. When you are finished, you should have 1 check mark. For any decisions above this check mark, Option A will be used. For any decisions below and including the check mark, Option B will be used.
    </p>
    <img :src='"14anita/images/" + player.option.filename'>
    <div>{{player.option.text}}</div>
    <br><br>
    <table style='font-size: 14pt; border-spacing: 0px;'>
        <tr style='background-color: #AAA'>
            <th>Option A</th>
            <th>Option B</th>
            <th>Switch</th>
        </tr>
        <tr v-for='(alternative, key) in player.option.alternativesList'>
            <td
                class='option'
                v-bind:class="{
                    red: player.switchRow != -1 && player.switchRow > key,
                    fontRed: player.previewSwitchRow != -1 && player.previewSwitchRow > key
                }" 
                onmouseenter='hoverRow(this)'
                onmouseleave='clearPreview()'
                onclick='clickRow(this)'
            >
                {{player.option.text}}
            </td>
            <td 
                class='option'
                v-bind:class="{
                    blue: player.switchRow != -1 && player.switchRow <= key,
                    fontBlue: player.previewSwitchRow != -1 && player.previewSwitchRow <= key
                }" 
                onmouseenter='hoverRow(this)'
                onmouseleave='clearPreview()'
                onclick='clickRow(this)'
            >
                {{alternative}} tokens for sure
            </td>
            <td style='text-align: center'><input type='radio' required name='player.switchRow' :value='alternative' :checked='player.switchRow == key' :onclick='"setRow(" + key + ")"'></td>
        </tr>
        <input type='radio' required name='player.switchRow' hidden value='unknown' :checked='player.switchRow == player.option.alternativesList.length'>
    </table>
    <div>Choice: {{player.switchRow}}</div>
    <div>Switch-to-B Tokens: {{player.switchToBTokens}}</div>
    <button :disabled='player.switchRow == -1'>OK</button>
    <script>
    clickRow = function(target) {
        let row = target.parentElement;
        setRow(row.rowIndex-1 + (1-target.cellIndex));
    }
    hoverRow = function(target) {
        let row = target.parentElement;
        jt.vue.player.previewSwitchRow = row.rowIndex-1 + (1-target.cellIndex);
    }
    clearPreview = function() {
        jt.vue.player.previewSwitchRow = -1;
    }
    setRow = function(x) {
        jt.vue.player.switchRow = x;
        jt.vue.player.switchToBTokens = 'unknown';
        if (x < jt.vue.player.option.alternativesList.length) {
            jt.vue.player.switchToBTokens = jt.vue.player.option.alternativesList[x];
        }
    }
    </script>
    <style>
        th {
            padding: 5px;
            padding-top: 15px;
            padding-bottom: 15px;
        }
        td.option {
            padding: 5px;
            padding-top: 15px;
            padding-bottom: 15px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        td.option:hover {
            border: 2px solid #000;
        }
        .red {
            background-color: rgba(255, 0, 0, 0.4);
        }
        .fontRed {
            color: red;
        }
        .blue {
            background-color: rgba(0, 0, 255, 0.4);
        }
        .fontBlue {
            color: blue;
        }
    </style>
`
stage.playerEnd = function(player) {
    player.draw = Math.floor(Math.random()*(player.option.alternativesList.length+1));
    if (player.draw > player.switchRow) {
        player.payoff = player.option.alternativesList[player.draw] + ' tokens';
    } else {
        player.payoff = player.option.text;
    }

    player.participant.latestPayoffs.push(player.payoff);
    if (player.period().id == app.numPeriods) {
        let round = Utils.randomInt(0, app.numPeriods);
        let drawnPayoff = player.participant.latestPayoffs[round];
        player.participant.payoffs.push({
            round: round,
            payoff: drawnPayoff,
            block: 'Block 1 Pref. Int.'
        });
    }
}

stage.autoplay = `
    if (jt.vue.player.switchRow == -1) {
        let x = Math.floor(Math.random()*(jt.vue.player.option.alternativesList.length+1));
        setRow(x)
    } else {
        $('form').submit();
    }
`